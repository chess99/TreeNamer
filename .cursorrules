# TreeNamer - Cursor Rules

## Project Structure

- `src/` - Frontend React/TypeScript code
- `src-tauri/` - Rust backend code (Tauri)
- `docs/` - Project documentation

## Key Development Patterns

### Core Principles

- Fully understand code logic before making changes - review all related code files first
- Follow Test-Driven Development (TDD) principles
- Update documentation when changing architecture or APIs
- Document only significant challenges and solutions

### Documentation References

- `docs/10-technical-solution-design.md` - Architecture overview
- `docs/31-architecture-decision-records.md` - Key design decisions
- `docs/03-implementation-status.md` - Current progress

## Critical Implementation Notes

### Tree Data Flow

1. Backend generates tree JSON with unique node IDs
2. Frontend formats JSON to text display format
3. User edits text representation
4. Frontend parses text back to JSON, preserving original IDs
5. Backend detects renames by comparing paths for same IDs

### ID Preservation Pattern

Always preserve node IDs during tree parsing to correctly detect renames:

```typescript
// Use ID mapping to track entity identity across edits
const nodeId = idMapping.get(lineNumber) || generateNewId();

// Create node with preserved ID
const node = {
  id: nodeId,  // Preserves entity identity for rename tracking
  name: nodeName,
  is_dir: isDirectory,
  children: []
};
```

### Critical Regex Patterns

For tree text parsing, use proper regex to extract node names:

```typescript
// Extract filename from tree formatting characters
const treeFormatRegex = /^(?:[│├└]\s*)*(?:[├└]──\s+)(.+)$/;
const match = line.match(treeFormatRegex);
  
if (match && match[1]) {
  // Extract the actual filename
  name = match[1];
}
```

### Tauri Integration

For Tauri commands with camelCase parameters, use:

```rust
#[command]
pub fn parse_directory(
    #[allow(non_snake_case)] dirPath: String, 
    options: Option<DirectoryOptions>
) -> Result<String, String> {
    // Now JavaScript can call this with { dirPath: path }
}
```

### Testing Setup

Use Vitest for frontend testing:

```bash
# Test scripts in package.json
"scripts": {
  "test": "vitest run",
  "test:watch": "vitest"
}
```

{{ARCHITECTURE_UPDATE}}
{{BEST_PRACTICES}}
{{TECH_DEBT}}
